<!DOCTYPE html>
<html>
<head>
    <title>RouteSync | Live Bus View</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" sizes="32x32" href="assets/favicon.png">
    <link rel="shortcut icon" href="assets/favicon.png">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />

    <style>
        body { margin: 0; padding: 0; font-family: 'Inter', 'Segoe UI', sans-serif; }
        #map { height: 100vh; width: 100%; }
        
        /* Clean UI: Hide the routing instruction panel */
        .leaflet-routing-container { display: none; }

        /* Style for the stop name labels (Tooltips) */
        .stop-label-style {
            background: white;
            border: 1.5px solid #3b82f6;
            border-radius: 6px;
            padding: 4px 10px;
            font-weight: 700;
            color: #1e293b;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            font-size: 13px;
        }

        /* Smoothing the bus movement via CSS transition */
        .leaflet-marker-icon {
            transition: transform 0.3s linear;
        }
    </style>
</head>
<body>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.min.js"></script>
<script src="https://unpkg.com/leaflet-marker-slide_to@latest/dist/leaflet-marker-slide_to.js"></script>

<script src="route_data.js"></script>

<script>
    // 1. SETTINGS & INITIALIZATION
    const activeRouteId = localStorage.getItem('selectedRouteId') || "1";
    const map = L.map('map').setView([27.7172, 85.3240], 14);

    L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
        attribution: 'Â© CARTO'
    }).addTo(map);

    // 2. DEFINE ICONS
    const stopIcon = L.icon({
        iconUrl: 'assets/stop-icon.png',
        iconSize: [32, 32],
        iconAnchor: [16, 32]
    });

    const busIcon = L.icon({
        iconUrl: 'assets/bus.png',
        iconSize: [45, 45],
        iconAnchor: [22, 22] // Centered for rotation
    });

    // 3. DRAW ROUTE (SHORTEST PATH)
    if (typeof allRoutes !== 'undefined' && allRoutes[activeRouteId]) {
        const stops = allRoutes[activeRouteId];
        const waypoints = stops.map(s => L.latLng(s.lat, s.lng));

        L.Routing.control({
            waypoints: waypoints,
            addWaypoints: false,
            draggableWaypoints: false,
            show: false,
            router: L.Routing.osrmv1({
                serviceUrl: 'https://router.project-osrm.org/route/v1',
                profile: 'car' // Finds shortest road-legal path
            }),
            lineOptions: {
                styles: [{ color: '#3b82f6', opacity: 0.7, weight: 6 }]
            },
            createMarker: function(i, wp) {
                const marker = L.marker(wp.latLng, { icon: stopIcon });

                // Interactive: Show name on click/hover
                marker.bindTooltip(stops[i].name, {
                    permanent: false,
                    sticky: true,
                    direction: 'top',
                    className: 'stop-label-style'
                });

                marker.on('click', (e) => map.setView(e.target.getLatLng(), 16));
                return marker;
            }
        }).addTo(map);
    }

    // 4. LIVE BUS TRACKING (SLIDING & ROTATING)
    let busMarkers = {};     // store markers per bus_id
	let lastPositions = {}; // store last position per bus


    // Helper: Calculate bearing angle for rotation
    function calculateBearing(lat1, lng1, lat2, lng2) {
        const dLng = (lng2 - lng1) * (Math.PI / 180);
        const y = Math.sin(dLng) * Math.cos(lat2 * (Math.PI / 180));
        const x = Math.cos(lat1 * (Math.PI / 180)) * Math.sin(lat2 * (Math.PI / 180)) -
                  Math.sin(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) * Math.cos(dLng);
        return (Math.atan2(y, x) * (180 / Math.PI) + 360) % 360;
    }

function updateBus() {
console.log("Polling server...");


    fetch("get_bus.php", {
        method: "POST",
        body: new URLSearchParams({ route_id: activeRouteId })
    })
    .then(res => res.json())
    .then(data => {

    if (!data.success || !data.buses || data.buses.length === 0) return;
    const activeBusIds = {};


    data.buses.forEach(bus => {

        const busId = bus.bus_id;
        activeBusIds[busId] = true;
        const newLat = parseFloat(bus.latitude);
        const newLng = parseFloat(bus.longitude);
        const newPos = L.latLng(newLat, newLng);

        if (!busMarkers[busId]) {
            busMarkers[busId] = L.marker(newPos, {
                icon: busIcon,
                rotationAngle: 0,
                rotationOrigin: 'center'
            }).addTo(map);

            lastPositions[busId] = newPos;
            return;
        }


        const lastPos = lastPositions[busId];
        const angle = calculateBearing(lastPos.lat, lastPos.lng, newLat, newLng);

        busMarkers[busId].setRotationAngle(angle);
        busMarkers[busId].slideTo(newPos, { duration: 2000 });

        lastPositions[busId] = newPos;
    });
    for (const id in busMarkers) {
    		if (!activeBusIds[id]) {
        		map.removeLayer(busMarkers[id]);
        		delete busMarkers[id];
        		delete lastPositions[id];
    		}
	}

})
.catch(err => console.log("Fetch error:", err));

}


    // Run update every 2 seconds
    setInterval(updateBus, 2000);
    updateBus();

</script>

</body>
</html>